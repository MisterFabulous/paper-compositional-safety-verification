\section{The Algorithm}
\label{sec:topic}

In the previous chapter we covered the formal basics of a program graph and invariants and introduced an example graph, which we will inspect in this chapter.

The algorithm uses a bottom-up approach. It analyses each component (SCC) of a program and combines the results.
In a first step we will abstract from the analysis of the components, treat them as given and introduce the combination of the analysis to give an overview first.
The analyzer of the components is called CondSafe, while the overall combination is called CheckSafe.

\subsection{CheckSafe}

The given program consists of the three SCCs $C_0$, $C_1$ and $C_2$.
The SCC $C_2$ has an exit transition $t_6$ which is annotated with an assertion $x \neq y$.
The overall algorithm first tries to find a CII which holds directly before $C_2$ and which satisfies the assertion condition.
The only transition in $C_2$ is $t_5$. If $t_5$ occurs in an evaluation, it has no effect on the equality of $x$ and $y$, since it increments both $x$ and $y$ with the same constant.
Therefore we can conclude that if we can show that prior to $C_2$ for every evaluation $x \neq y$ holds, it will also hold after $C_2$.

Unfortunately CondSafe is only able to find either the CII $x > y$ or $y > x$. This does not affect correctness since both CIIs imply $x \neq y$, but it affects completeness.
Therefore the authors of the original paper introduced a technique they called narrowing.
The idea behind narrowing is to try first to prove safety with the CII CondSafe returns.
If this fails CheckSafe is then able to backtrack, filter evaluations and force CondSafe to return a different CII.

We assume the analyzer finds the CII $x > y$ first.
The algorithm will now try to recursively find further CIIs such that $x > y$ holds after each component occurring directly before $C_2$.

The entry transitions of $C_2$ are $t_2$ and $t_4$.
The SCC that has $t_2$ as exit transition is $C_0 = \emptyset$, the SCC that has $t_4$ as exit transition is $C_1 = \lbrace t_3 \rbrace$.
We need to find a CII for both SCCs, otherwise narrowing is necessary.
Since $y > x$ has to be satisfied for $t_2$ to occur in an evaluation, both $y > x$ and $x > y$ need to be satisfied by the same evaluation step.
Those conditions contradict each other, therefore there is no evaluation satisfying the postcondition and no precondition can be found to imply the postcondition.

The SCC before $t_4$ is $C_1$.
We need to find a CII that ensures that after $C_1$ it holds that $x > y$.
If we run CondSafe for this SCC it could return $i > 0 \wedge x \geq y$ as precondition for $t_1$, because it ensures that $t_3$ is run at least once and therefore implies that $x > y$ holds at $t_4$.

The literals of both preconditions now get propagated independently to $C_0$.
$x \geq y$ is directly implied by the condition of $t_1$ and therefore this part of the CII is safe.
For the safety prove of $i > 0$ we need to inspect $C_0$.
Since $C_0 = \emptyset$ CondSafe will detect that the postcondition has already to be met at the entry transitions, therefore the preconditions equal the postconditions.
Because the only entry transition $t_0$ of $C_0$ implies $i > 0$, CondSafe proves the SCC as safe and propagates this result back to $C_2$.

At this point CheckSafe knows that $x > y$ holds after every occurrence of $t_4$ for every evaluation, but it does not hold for $t_2$.
Therefore we need to narrow the program and find the CII $y > x$ instead.
Since we already found $t_4$ to be safe, we inspect $t_2$ with this CII.
For the exit transition $t_2$ of $C_0$ the condition of the transition now implies the postcondition $y > x$.
Therefore this path is also proved safe.

\begin{algorithm}
\caption{CheckSafe}\label{checksafe}
\begin{algorithmic}[1]
  \State Input: The program, an SCC, the entry transitions of the SCC, an exit transition with an assertion
  \If {the exit transition already implies the assertion}
    \Return Safe
  \ElsIf {the exit transition is an initial transition}
    \Return Maybe
  \EndIf
  \State Call CondSafe for the SCC with the given assertion
  \If {no CII could be found}
    \Return Maybe
  \EndIf
  \ForAll {entry SCCs}
    \ForAll {literals of the according condition of the CII}
      \State Call CheckSafe for the entry SCC and with the literal as assertion
    \EndFor
  \EndFor
  \If {all calls returned Safe}
    \Return Safe
  \EndIf
  \Return the result of a call to CheckSafe with a narrowed version
\end{algorithmic}
\end{algorithm}


\subsection{Narrowing}

Until this point we abstracted from the inner workings of narrowing.
The idea of narrowing is to manipulate the original program, such that the algorithm CondSafe is able to find a different CII to show safety for not yet proved paths.
In the example program it would be sufficient to show that the post condition $x > y$ holds after each evaluation step before the location $l_2$.
But this can not be shown for one entry transitions, therefore we try to use narrowing.

\begin{algorithm}
\caption{Narrowing}\label{narrowing}
\begin{algorithmic}[1]
  \ForAll {entry transitions}
    \ForAll {literals of the CII}
      \If {literal could not be proved safe for this transition}
        \State Add a conjunct with the negated literal to the transition
      \EndIf
    \EndFor
  \EndFor
  \ForAll {transitions of the SCC}  
    \State Add a conjunct with the negated CII at the start location to the transition
    \State Add a conjunct with the negated CII at the end location to the transition
  \EndFor
\end{algorithmic}
\end{algorithm}

We exclude those evaluations we could not prove safe by adding the negated literals of the CII to those entry transitions that could not be proved safe for the literal.
In the example program we add to $t_2$ the additional constraint $\neg (x > y)$ which is equivalent to $x \leq y$.
This way we guarantee that no evaluation with $x > y$ at the entry transitions passes to $C_2$ and therefore they got excluded from the program.

Additionally we can modify the transitions inside an SCC to exclude further evaluations, because $x > y$ is either true at the start location or at the end location of the transition.
\todo{Maybe add more explanation}

After narrowing we obtain the program graph presented in figure \ref{fig:narrowed}. The added conditions are colored blue.

\begin{figure}
\centering
\begin{tikzpicture}[->,>=stealth',auto,node distance=3.5cm,
    thick,
    main node/.style={circle,draw,font=\sffamily\Large\bfseries},
    aligned edge/.style={align=left}]

  \node[main node] (0) {$l_0$};
  \node[main node] (1) [right of=0] {$l_1$};
  \node[main node] (2) [right of=1] {$l_2$};

  \node (4) [right of=2] {};
  \node (5) [left of=0] {};
  
  \path[every node/.style={font=\sffamily\small}]
    (0) edge[aligned edge] node {$t_1: x \geq y$} (1)
        edge[aligned edge, bend right=25] node [below] {$t_2: y > x \wedge \mathbf{x \leq y}$} (2)
    (1) edge[aligned edge, loop above] node {$t_3:$\\$i > 0 \wedge$\\$x' = x + 1 \wedge$\\$i' = i - 1$} (1)
        edge[aligned edge] node {$t_4:$\\$i = 0$} (2)
    (2) edge[aligned edge, loop above] node {$t_5:$\\$x' = x + 1 \wedge$\\$y' = y + 1 \wedge$\\$\mathbf{x \leq y}$} (2)
        edge[aligned edge] node {$t_6$, assert($x \neq y$)} (4)
    (5) edge[aligned edge] node {$t_0: i > 0$} (0);
\end{tikzpicture}
\caption{Narrowed example program}
\label{fig:narrowed}
\end{figure}

The addition of narrowing has the effect of adding backtracking to the main algorithm.
It leads to a tree-like exploration from the exit state on to the initial states.
Only if the exploration can successfully reach every initial state for each sequence of SCCs safety is guaranteed.
This is shown by figure \ref{fig:backtrack}.
For the example it is sufficient to explore the one of the leaves with $t_4$ in its path to the root and one of the leaves with $t_2$ in its path to the root.
The algorithm first detects $x < y$ as precondition of $l_2$, which we can not prove safe for neither of the two paths.
Therefore the other two paths both must ensure safety.
The number of possible narrowing steps at $l_2$ is two in this example, but in more complex programs there can be an arbitrary number of narrowing steps necessary at a SCC.

\begin{figure}
  \centering

  \begin{sequencediagram}
    \newinst{caller}{Caller}
    \newinst[1.5]{c2}{$C_2$}
    \newinst[3]{c1}{$C_1$}
    \newinst[3]{c0}{$C_0$}

    \begin{call}{caller}{CheckSafe($t_6$, $x \neq y$)}{c2}{Safe}
      \begin{call}{c2}{CondSafe($x \neq y$)}{c2}{$x > y$}\end{call}
      \begin{call}{c2}{CheckSafe($t_2$, $x > y$)}{c0}{Maybe}
        \begin{call}{c0}{CondSafe($x > y$)}{c0}{None}\end{call}
      \end{call}
      \begin{call}{c2}{CheckSafe($t_4$, $x > y$)}{c1}{Maybe}
        \begin{call}{c1}{CondSafe($x > y$)}{c1}{$i > 0 \wedge x \geq y$}\end{call}
        \begin{call}{c1}{CheckSafe($t_1$, $i > 0$)}{c0}{Safe}
          \begin{call}{c0}{CondSafe($i > 0$)}{c0}{$i > 0$}\end{call}
        \end{call}
        \begin{call}{c1}{CheckSafe($t_1$, $x \geq y$)}{c0}{Safe}
        \end{call}
      \end{call}
      \begin{call}{c2}{narrow()}{c2}{}\end{call}      
      \begin{call}{c2}{CondSafe($x \neq y$)}{c2}{$y > x$}\end{call}
      \begin{call}{c2}{CheckSafe($t_2$, $y > x$)}{c0}{Maybe}
        \begin{call}{c0}{CondSafe($y > x$)}{c0}{Safe}\end{call}
      \end{call}
    \end{call}
  \end{sequencediagram}

  \caption{Sequence diagram for the example program}
\end{figure}

\subsection{CondSafe}

Another procedure the algorithm CheckSafe uses is the algorithm CondSafe.
It analyses SCCs of the program and tries to find a CII such that a post condition is implied.

For performance reasons it only takes a post condition which consists of a single clause.
This is not a real restriction, because each conjunction of conditions can be split into single transitions and be analyzed independently.

The aim is to find an invariant that consists of as less conjunctions of clauses as possible.
Therefore the algorithm uses an iterative approach.
In a first step it tries to find an invariant consisting of a single clause.
If this is not possible, it expands its search spectrum and searches for clauses consisting of two clauses.
The algorithm terminates if either an invariant with a specific count of clauses is found or a certain constant is reached.

\begin{algorithm}
\caption{CondSafe}\label{condsafe}
\begin{algorithmic}[1]
\State Input: An SCC, the entry transitions of the SCC, an exit transition with an assertion
\State $k \gets 1$
\Repeat
  \State Construct a formula $\mathbb{F}_k$ for the SCC and the assertion
  \State Call the Max-SMT-Solver with $\mathbb{F}_k$
  \If {it returned a solution}
    \Return an invariant assigning each location the according condition from $\mathbb{F}_k$
  \EndIf
  \State $k \gets k + 1$
\Until{$k > \text{MAX\_CONJUNCTS}$}
\Return None
\end{algorithmic}
\end{algorithm}

To find a CII with a certain size of clauses the algorithm uses a Max-SMT-Solver, which will be explained in the next chapter.

\subsubsection{Max-SMT}

Let $\mathcal{P}$ be a fixed set of propositional variables.
We call $p$ and $\neg p$ literals for all $p \in \mathcal{P}$.
We define a clause as disjunction of literals $l_1 \vee \dots \vee \l_n$ and a propositional formula as conjunction of clauses $C_1 \wedge \dots \wedge C_m$.

With a SAT-Solver it is possible to determine if a propositional formula is satisfiable.
An SMT-Solver is able to check the satisfiability of a formula with literals from a given background theory.
For both solvers there exist extensions called Max-SAT and Max-SMT.
Those extensions provide the possibility to declare constraints as soft with a weight.
A soft constraints does not have to be satisfied, but the solver will try to maximize the sum of the weights of the soft constraints.

Formally a Max-SMT problem is a formula $H_1 \wedge \dots \wedge H_n \wedge [S_1,\omega_1] \wedge \dots \wedge [S_m,\omega_m]$, where $H_i$ denote the hard clauses, which also occur in an SMT problem, and $[S_i,\omega_i]$ denote the soft clauses and their weight.

To find CIIs for program parts we create hard constraints for the consecution and safety conditions and a soft constraint for the initiation condition.
While the consecution condition ensures that the invariant is inductive and the safety condition ensures that the assertion is implied, the initiation condition does not need to be fulfilled and thus the resulting invariant might depend on additional preconditions.  

In the definition of the condition we use for each location in the SCC the templates $I_{\ell,k}$ and $I_{\ell,j,k}$, where $I_{\ell,k}$ is a conjunction of $k$ templates $I_{\ell,j,k}$.
\begin{align}
  I_{\ell,k}(\mathcal{V}) \equiv & \bigwedge_{1 \leq j \leq k}{I_{\ell,j,k}(\mathcal{V})}\\
  I_{\ell,j,k}(\mathcal{V}) \equiv & i_{\ell,j} + \sum_{v \in \mathcal{V}}{i_{\ell,j,v} * v} \leq 0
\end{align}
For instance the template for the SCC $\mathcal{C}_2 = \lbrace t_5 \rbrace$ and a $k=1$ is \[ I_{\ell_2,1}(\lbrace x, y, i \rbrace) \equiv i_{\ell_2,1} + i_{\ell_2,1,x} * x + i_{\ell_2,1,y} * y + i_{\ell_2,1,i} * i \leq 0 \]
We write $I'_{\ell,k}$ instead of $I_{\ell,k}$ if we use $v' \in \mathcal{V}'$ instead of $v \in \mathcal{V}$.

With those templates we define the initiation condition for a transition $t = (\ell, \tau, \ell') \in \mathcal{E}_\mathcal{C}$ and numbers $j, k \in \mathbb{N}$ with $1 \leq j \leq k$ as $\mathbb{I}_{t,j,k}$.
For each transition $t = (\ell, \tau, \ell') \in \mathcal{C}$ and number $k \in \mathbb{N}$ we define the consecution condition as $\mathbb{C}_{t,k}$.
The safety condition we define for an exit transition $t_\text{exit} = (\tilde{\ell}_\text{exit}, \tau_\text{exit}, \ell_\text{exit})$ as $\mathbb{S}_k$.
\begin{align}
  \mathbb{I}_{t,j,k} \equiv & \tau \Rightarrow I'_{l',j,k}\\
  \mathbb{C}_{t,k} \equiv & I_{\ell,k} \wedge \tau \Rightarrow I'_{\ell,k}\\
  \mathbb{S}_k \equiv & I_{\tilde{\ell}_\text{exit},k} \wedge \tau_\text{exit} \Rightarrow \varphi'
\end{align}

For instance for the SCC $\mathcal{C}_2$ and $k=1$ the two initiation conditions are $\mathbb{I}_{t_2, 1, 1}$ and $\mathbb{I}_{t_4, 1, 1}$.
The single consecution condition is $\mathbb{C}_{t_5, 1}$.
The single safety condition is $\mathbb{S}_1$.
\begin{align}
  \mathbb{I}_{t_2, 1, 1} \equiv & i \geq x \Rightarrow i_{\ell_2,1} + i_{\ell_2,1,x} * x' + i_{\ell_2,1,y} * y' + i_{\ell_2,1,i} * i' \leq 0\\
  \mathbb{I}_{t_4, 1, 1} \equiv & y > x \Rightarrow i_{\ell_2,1} + i_{\ell_2,1,x} * x' + i_{\ell_2,1,y} * y' + i_{\ell_2,1,i} * i' \leq 0\\
  \begin{split}
    \mathbb{C}_{t_5, 1} \equiv & i_{\ell_2,1} + i_{\ell_2,1,x} * x + i_{\ell_2,1,y} * y + i_{\ell_2,1,i} * i \leq 0 \wedge x' = x + 1 \wedge y' = y + 1\\
    & \Rightarrow i_{\ell_2,1} + i_{\ell_2,1,x} * x' + i_{\ell_2,1,y} * y' + i_{\ell_2,1,i} * i' \leq 0
  \end{split}\\
  \mathbb{S}_1 \equiv & i_{\ell_2,1} + i_{\ell_2,1,x} * x + i_{\ell_2,1,y} * y + i_{\ell_2,1,i} * i \leq 0 \wedge \text{true} \Rightarrow x' \neq y'
\end{align}
  
Those templates for the three different conditions we can put together in a Max-SMT problem:
\[ \mathbb{F}_k \equiv \bigwedge_{t \in \mathcal{C}} \mathbb{C}_{t, k} \wedge \mathbb{S}_k \wedge \bigwedge_{t \in \mathcal{E}_\mathcal{C}, 1 \leq j \leq k}{(\mathbb{I}_{t,j,k} \vee \neg p_{\mathbb{I}_{t,j,k}})} \wedge \bigwedge_{t \in \mathcal{E}_\mathcal{C}, 1 \leq j \leq k}{[p_{\mathbb{I}_{t,j,k}}, \omega_\mathbb{I}]} \]
The propositional variables are necessary, because the Max-SMT-Solver is only able to maximize variables and no whole conditions.
With the used formula we achieve that if $p_{\mathbb{I}_{t,j,k}}$ is decided to be true, the the initiation condition $\mathbb{I}_{t,j,k}$ also needs to be satisfied.

For the example this is equal to:
\[ \mathbb{F}_1 \equiv \mathbb{C}_{t_5, 1} \wedge \mathbb{S}_1 \wedge ((\mathbb{I}_{t_2,1,1} \vee \neg p_{\mathbb{I}_{t_2,1,1}}) \wedge (\mathbb{I}_{t_4,1,1} \vee \neg p_{\mathbb{I}_{t_4,1,1}})) \wedge ([p_{\mathbb{I}_{t_2,1,1}}, \omega_\mathbb{I}] \wedge [p_{\mathbb{I}_{t_4,1,1}}, \omega_\mathbb{I}]) \]

If we assume the Max-SMT-Solver returned $x > y$ as maximally satisfying condition for $\mathbb{F}_1$, we can verify if this is a model.
The condition $x > y$ relates to the template instantiated with $I_{\ell,1}(\lbrace x, y, i \rbrace) \equiv 1 + (-1) * x + 1 * y + 0 * i \leq 0$.
Inserted into the initiation, safety and consecution condition we get:
\begin{align}
  \mathbb{I}_{t_2, 1, 1} \equiv & i \geq x \Rightarrow x' > y'\\
  \mathbb{I}_{t_4, 1, 1} \equiv & y > x \Rightarrow x' > y'\\
  \mathbb{C}_{t_5, 1} \equiv & x > y \wedge x' = x + 1 \wedge y' = y + 1 \Rightarrow x' > y'\\
  \mathbb{S}_1 \equiv & x > y \wedge \text{true} \Rightarrow x' \neq y'
\end{align}

\todo{Verify with example}

\todo{Check formulas}
